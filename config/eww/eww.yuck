
; TIME
(defpoll time
  :interval "1s"
  `date +%H:%M`)
(defpoll date
  :interval "10s"
  :initial '{"value": "...", "length": 0}'
  `~/dots/config/eww/sh/date.sh`)

; DISK (BTRFS)
(defpoll fsused
  :interval "1s"
  :initial "0"
  `btrfs filesystem usage / | awk '/^\\s*Used/ {print $2+0}'`)
(defpoll fscap
  :interval "5s"
  :initial "100"
  `btrfs filesystem usage / | awk '/size/ {print $3+0}'`)

; PIPEWIRE
(defpoll sound
  :interval "1s"
  :initial "100"
  `amixer sget Master | awk '/Left: Playback/ {print substr($5,2,3)+0}'`)

; BRIGHTNESS
(defpoll brightness
  :interval "1s"
  :initial "100"
  ; love it when the tool does just what you want without needed to pipe awk and sed.
  `light -G`)

; MPD STUFF
(deflisten mpd-track
  :initial "..."
  `mpc idleloop player  | while read _; do mpc current -f '[[[%artist%]|[%album%]] - %title%]|%file%';          done`)
(deflisten mpd-track-short
  :initial "..."
  `mpc idleloop player  | while read _; do mpc current -f '[%title%]|%file%';                                   done`)
(deflisten mpd-volume
  :initial "50"
  `mpc idleloop mixer   | while read _; do mpc status %volume% | awk '{print $0+0}';                            done`)
(deflisten mpd-repeat
  :initial "false"
  `mpc idleloop options | while read _; do mpc status %repeat% | awk '{print $0=="on" ? "true" : "false"}';        done`)
(deflisten mpd-random
  :initial "false"
  `mpc idleloop options | while read _; do mpc status %random% | awk '{print $0=="on" ? "true" : "false"}';        done`)
(deflisten mpd-single
  :initial "false"
  `mpc idleloop options | while read _; do mpc status %single% | awk '{print $0=="on" ? "true" : "false"}';        done`)
(deflisten mpd-playing
  :initial "false"
  `mpc idleloop player | while read _; do mpc status %state% | awk '{print $0=="playing" ? "true" : "false"}';        done`)
; has to be poll obviously
(defpoll mpd-trough
  :interval "500ms"
  :initial "0"
  `mpc status %percenttime% | awk '{print $0+0}'`)

; unused as of now, maybe later
(defpoll kernel
  :interval "3600s"
  :initial ""
  `uname -r | awk -F'-' '{print $1}'`)
(defpoll uptime
  :interval "60s"
  :initial ""
  `uptime -p | cut -d' ' -f2-`)

; GITHUB
(defpoll gh-user-info
  :interval "3600s"
  :initial '{"name":"","login":"","email":""}'
  ; name: displayed name, login: actual name, email is optional
  `~/dots/config/eww/sh/github.sh user_info`)
(defpoll gh-avatar ; the path to the avatar image
  :interval "3s" ; the script will just return the path to the image
  :initial ''    ; most of the time so this is nothing too expensive
  `~/dots/config/eww/sh/github.sh avatar`)

; SWAY
(deflisten sway-workspaces
  :initial '[{"focused":false,"used":false},{"focused":false,"used":false},{"focused":false,"used":false},{"focused":false,"used":false},{"focused":false,"used":false},{"focused":false,"used":false},{"focused":false,"used":false},{"focused":false,"used":false}]'
  ; jq magic
  `while true; do swaymsg -t subscribe '["workspace"]' >/dev/null && swaymsg -t get_workspaces -r | jq '[.[] | {name: .name | tonumber, focused, used: true}] + [range(1;9) | {name:., focused: false, used: false}   ] | unique_by(.name) | sort_by(.name) | [.[] | {focused, used}]' -cM; done`)

(defvar sidebar-revealed "false")
; used to make the mpd seek bar (that shows how far into the song were
; currently) only interactive when the mouse is over. This is done to
; avoid audio glitchs because the bar makes a loop:
;  - mpd plays the song, and gets further into it
;  - this is noticed by the mpd-through var
;  - the var then updates the value of the bar
;  - the bar sees its value updated and calls its onchange "callback"
;  - and the "callback" tells mpd to go this far into the song.
; Problem is that this is done with a delay, caused by the poll interval
; and how many things it needs to go through, so the song ends up going
; ~100ms back every 1-2s, which is very annoying.
(defvar mpd-hover-seek "false") 
; TODO: set that back to 0 when page 2 is done
(defvar sidebar-page 1)
; remember to update that
(defvar sidebar-page-max 3)
; wether the reload button should be displayed
(defvar gh-reload-avatar false)

(defwindow sidebar
           :monitor 0
           :geometry (geometry :x "0%"
                               :y "0%"
                               :width "300px"
                               :height "100%"
                               :anchor "center left")
           :stacking "overlay"
           :exclusive false
  (box :orientation "h"
    :class "bar_parent"
    :space-evenly "false"
    (eventbox
      (revealer :reveal sidebar-revealed
        :transition "slideright"
        :duration "250ms"
        (box :class "bar"
          :orientation "v"
          :space-evenly "false"
          (box :orientation "v" ; top
            :valign "start"
            :vexpand "true"
            :space-evenly "false"
            (bpage :index "0"
              ; DATE
              (box :class "date ${date.length > 27 ? "date_smaller" : ""}"
                "${date.value}")

              (box :class "line")

              ; TIME
              (box :class "time"
                "${time}")

              (box :class "line")
              (space)

              ; SYSTEM INFO
              (box :space-evenly false
                (box :class "bat"
                  :space-evenly "false"
                  :orientation "v"
                  (box :class "bat_top"
                    :halign "center")
                  (box :class "bat_body"
                    :halign "center"
                      (box :class "bat_prog"
                        :valign "end"
                        :style "min-height: ${148 * (EWW_BATTERY.BAT0.capacity / 100)}px;"
                        (box :class "bat_info"
                          :orientation "v"
                          :valign "center"
                          :halign "center"
                          (icon :icon "${EWW_BATTERY.BAT0.status == "Charging" ? "󱐋" : ""}"))))
                    (box :class "bat_cap"
                      "${EWW_BATTERY.BAT0.capacity}%"))
                (box :orientation "v"
                  :halign "start"
                  :class "prog_wrap"
                  :space-evenly false
                  (box :space-evenly false
                    :class "prog_inst"
                    (circular-progress :value "${EWW_RAM.used_mem_perc}"
                      :thickness "10"
                      :class "prog_ram"
                      :halign "start"
                      :start-at "0"
                        (box :class "prog"
                          "${round(EWW_RAM.used_mem_perc, 0)}%"))
                    (box :class "prog_label" 
                      "ram"))
                  (box :space-evenly false
                    :class "prog_inst"
                    (circular-progress :value "${EWW_CPU.avg}"
                      :tooltip "test"
                      :thickness "10"
                      :class "prog_cpu"
                      :valign "start"
                      :start-at "0"
                        (box :class "prog"
                          "${round(EWW_CPU.avg, 0)}%"))
                      (box :class "prog_label" 
                        "cpu"))
                  (box :space-evenly false
                    :class "prog_inst"
                    (circular-progress :value "${fsused / fscap * 100}"
                      :thickness "10"
                      :class "prog_disk"
                      :valign "start"
                      :start-at "0"
                        (box :class "prog"
                          "${round(fsused / fscap * 100, 0)}%"))
                      (box :class "prog_label" 
                        "disk"))))

              ; SCALES
              (box :orientation "v"
                :class "scales"
                :space-evenly false
                (box :space-evenly false
                  (scale :value "${sound}"
                    :halign "start"
                    :valign "center"
                    :class "scale s_sound"
                    :min "0"
                    :max "100"
                    :onchange "amixer sset Master {}%"
                    :orientation "h")
                  (box :class "scale_label"
                    "󰋋"))
                (box :space-evenly false
                  (scale :value "${brightness}"
                    :halign "start"
                    :valign "center"
                    :class "scale s_brightness"
                    :min "0"
                    :max "100"
                    :onchange "light -S {}"
                    :orientation "h")
                  (box :class "scale_label"
                    "󰃞"))
                )
              (space)
              (box :space-evenly false
                :class "mpd_wrap"
                :orientation "v"
                (box
                :space-evenly false
                  (centerbox :orientation "h"
                    :hexpand true
                    :class "mpd_track_wrap"
                    (button :halign "start"
                      :class "mpd_button"
                      :onclick "mpc prev"
                      "󰅁")
                      (label :halign "center"
                        :limit-width 21
                        ; regex goes brbrbrbrrbrbrbr

                        ; this line first compute the displayed title (see :text) and then uses a regex to:
                        ; if it is more than 20 chrs long, replace it with //__LONG__//,
                        ; if it isn't keep it as is. Then the result is matched to see if it is //__LONG__//,
                        ; and if it is the mpd_track_long class is added

                        ; TLDR; add the mpd_track_long class if the label is 20 chrs or more
                        :class "mpd_track ${replace("${replace("${mpd-track}", "^.{20,}$", "${mpd-track-short}")}", "^.{20,}$", "//__LONG__//") == "//__LONG__//" ? "mpd_track_long" : ""}"
                        ; this replaces mpd-track with mpd-track-short if mpd track is longer than 20 chrs.
                        :text "${replace("${mpd-track}", "^.{20,}$", "${mpd-track-short}")}")
                    (button :halign "end"
                      :class "mpd_button"
                      :onclick "mpc next"
                      "󰅂"))
                  (box :class "mpd_icon"
                    "󰎈"))
                (space-small)
                (box :space-evenly false
                    (button :onclick "mpc toggle"
                      (icon :icon "${mpd-playing ? "󰏤" : "󰐊"}"))
                    (button :onclick "mpc random"
                      (icon :icon "${mpd-random ? "󰒝" : "󰒞"}"))
                    (button :onclick "${mpd-repeat ? mpd-single ? "mpc single && mpc repeat" : "mpc single" : "mpc repeat"}"
                      (icon :icon "${mpd-repeat ? mpd-single ? "󰑘" : "󰑖" : "󰑗"}"))
                    (eventbox :onhover "eww update mpd-hover-seek=true"
                      :onhoverlost "eww update mpd-hover-seek=false"
                      (scale :value "${mpd-trough}"
                        :halign "start"
                        :valign "center"
                        :onchange "${mpd-hover-seek ? "mpc seek {}%" : ""}"
                        :min "0"
                        :max "100"
                        :orientation "h")))
                ;(space-long)
                ;(box :class "sysinfo"
                ;  :space-evenly "false"
                ;  (box :space-evenly false
                ;    (icon :halign "start"
                ;      :icon "󰌽"))
                ;    (label :text {kernel})
                ;  " "
                ;  (box :space-evenly false
                ;    :class "sysinfo_2"
                ;    (icon :halign "start"
                ;      :icon "󱑆")
                ;    (label :text {uptime})))
                ))
            (bpage :index 1
              (box :orientation "v"
                :space-evenly false
                :class "gh_page"
                (box :space-evenly false
                  :class "gh_header"
                  (button :onclick "eww update gh-reload-avatar=${!gh-reload-avatar}"
                    (box :style "background-image: url('${gh-avatar}')"
                      :class "gh_avatar"))
                  (box :orientation "v"
                    :space-evenly false
                    :hexpand true
                    (revealer :reveal {! gh-reload-avatar}
                      :transition "slidedown"
                      :duration "250ms"
                      (box 
                        :orientation "v"
                        :halign "center"
                        :class "gh_name"
                        (label :text {gh-user-info.name})
                        (label :text {gh-user-info.login}
                          :class "text_secondary")))
                    (revealer :reveal {gh-reload-avatar}
                      :transition "slidedown"
                      :duration "250ms"
                      :hexpand true
                      (box :class "gh_reload_avatar_wrap"
                        :space-evenly false
                        :halign "center"
                        (button :onclick `rm ${gh-avatar}; eww update gh-avatar=''; eww update gh-avatar=$(~/dots/config/eww/sh/github.sh avatar)`
                          :valign "center"
                          "󰑓 Avatar"))))))
            )
            (bpage :index 2
              "test2")                                          
            (bpage :index 3
              "test3")
            )
          (box :orientation "v" ; bottom
            :class "footer"
            :valign "end"
            :space-evenly "false"
            (space)
            (box :class "pages"
              (button :onclick `~/dots/config/eww/sh/page.sh first`
                (icon :icon "󰄽"))
              (button :onclick `~/dots/config/eww/sh/page.sh previous`
                (icon :icon "󰅁"))
              (label :text "${sidebar-page}")
              (button :onclick `~/dots/config/eww/sh/page.sh next`
                (icon :icon "󰅂"))
              (button :onclick `~/dots/config/eww/sh/page.sh last`
                (icon :icon "󰄾")))
            (box :class "sway"
              :space-evenly false
              (workspace :index "0")
              (workspace :index "1")
              (workspace :index "2")
              (workspace :index "3")
              (workspace :index "4")
              (workspace :index "5")
              (workspace :index "6")
              (workspace :index "7"))
            (space)
              ))))
    (box :class "shadow")))

(defwidget space-small []
  (box :class "space"
    :height 10))
(defwidget space []
  (box :class "space"
    :height 20))
(defwidget space-long []
  (box :class "space"
    :height 30))
(defwidget bpage [index]
  (revealer :reveal {sidebar-page == index}
    :transition "slidedown"
    :duration "250ms"
    (box :class "bar_page"
      :orientation "v"
      :space-evenly "false"
      (children))))
(defwidget workspace [index]
  (box :class "workspace ${sway-workspaces[index].focused ? "workspace-focused" : ""} ${sway-workspaces[index].used ? "" : "workspace-unused"}"))
(defwidget icon [icon]
  (box :class "icon"
    icon))
(defwidget battery []
  (icon :icon "${['󱃍','󰁺','󰁻','󰁼','󰁽','󰁾','󰁿','󰂀','󰂁','󰂂','󰁹','󰢟','󰢜','󰂆','󰂇','󰂈','󰢝','󰂉','󰢞','󰂊','󰂋','󰂅'][round(EWW_BATTERY.BAT0.capacity / 10, 0) + (EWW_BATTERY.BAT0.status == 'Charging' ? 10 : 0)]}"))

(defwindow test
  :monitor 0
  :geometry (geometry :x "0"
                      :y "0"
                      :width "150px"
                      :height "30px")
  :stacking "fg"
  (box :orientation "v"
    :space-evenly false
    (scrolling-box
      :class "test1"
      :halign "start"
      :valign "center"
      :width "49px"
      :height "30px"
      :speed "50px"
      (label :text "this is a really long string of text that exceeds the width of the label's width. ///"
        :class "test0"))
    (box :class "test2"
      :halign "start"
      :valign "start"
      :width "49"
      :height "10")))

; Hack to keep some variables updating
(defwindow _keepalive
           :monitor 0
           :geometry (geometry :x "100%"
                               :y "100%"
                               :width "0px"
                               :height "0px")
           :stacking "bg"
           :exclusive false
  (box
    "${sway-workspaces}"
    "${mpd-track}"
    "${mpd-track-short}"
    "${mpd-volume}"
    "${mpd-repeat}"
    "${mpd-random}"
    "${mpd-single}"
    "${mpd-playing}"
    "${mpd-trough}"
    ))
